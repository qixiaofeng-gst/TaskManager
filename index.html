<!DOCTYPE html>
<html lang="cn">
<head>
  <script>window.addEventListener('load', () => {
    const const_proxy_handler = new Proxy({
      get: (target, p, _) => target[p],
      set: () => {
        console.error('Constant could not be set')
        return false
      },
    }, {
      get: (target, p, _) => target[p],
      set: () => false,
    })
    const Colors = new Proxy({
      text: '#555555',
      footer_bg: '#f4fce8',
      border_lighter: '#ededed',
      white: '#ffffff',
      green: '#00bb00',
      gray: '#dddddd',
      yellow: '#ddcc00',
      shadow_lighter: 'rgba(0, 0, 0, .2)',
      button_bg: 'rgba(0, 0, 0, .1)',
    }, const_proxy_handler)
    const Displays = new Proxy({
      flex: 'flex',
      block: 'block',
      grid: 'grid',
      none: 'none',
    }, const_proxy_handler)
    const Repeats = new Proxy({
      no_repeat: 'no-repeat',
    }, const_proxy_handler)
    const Justifies = new Proxy({
      space_between: 'space-between',
    }, const_proxy_handler)
    const Aligns = new Proxy({
      center: 'center',
    }, const_proxy_handler)
    const Cursors = new Proxy({
      pointer: 'pointer',
    }, const_proxy_handler)
    const FontWeights = new Proxy({
      bold: 'bold',
    }, const_proxy_handler)
    const body = new Proxy({
      append: view => {
        document.body.append(view)
        return body
      },
    }, const_proxy_handler)

    class View extends HTMLElement {
      addView(newChild) {
        super.appendChild(newChild)
        return this
      }

      cutView(oldChild) {
        super.removeChild(oldChild)
        return this
      }

      setGridColumn(strTemplate, strGap) {
        this.style.gridColumnGap = strGap
        this.style.gridTemplateColumns = strTemplate
        return this
      }

      setAnimation(strValue) {
        this.style.animation = strValue
        return this
      }

      setWidth(strValue) {
        this.style.width = strValue
        return this
      }

      setHeight(strValue) {
        this.style.height = strValue
        return this
      }

      setFontWeight(strValue) {
        this.style.fontWeight = strValue
        return this
      }

      setBGColor(value) {
        this.style.backgroundColor = value
        return this
      }

      setBGImage(strValue) {
        this.style.backgroundImage = `url(${strValue})`
        return this
      }

      setBGPosition(strValue) {
        this.style.backgroundPosition = strValue
        return this
      }

      setBGSize(strValue) {
        this.style.backgroundSize = strValue
        return this
      }

      setBGRepeat(strValue) {
        this.style.backgroundRepeat = strValue
        return this
      }

      setDisplay(value) {
        this.style.display = value
        return this
      }

      setColor(value) {
        this.style.color = value
        return this
      }

      setPadding(value) {
        this.style.padding = value
        return this
      }

      setMargin(strValue) {
        this.style.margin = strValue
        return this
      }

      setShadow(value) {
        this.style.boxShadow = value
        return this
      }

      setBorderTop(value) {
        this.style.borderTop = value
        return this
      }

      setBorderBottom(strValue) {
        this.style.borderBottom = strValue
        return this
      }

      setJustifyContent(value) {
        this.style.justifyContent = value
        return this
      }

      setAlignItems(value) {
        this.style.alignItems = value
        return this
      }

      setFontSize(value) {
        this.style.fontSize = `${value}rem`
        return this
      }

      setLineHeight(value) {
        this.style.lineHeight = `${value}rem`
        return this
      }

      setRadius(strValue) {
        this.style.borderRadius = strValue
        return this
      }

      setCursor(value) {
        this.style.cursor = value
        return this
      }

      setContent(strValue) {
        this.innerHTML = strValue
        return this
      }
    }

    class Text extends View {
      constructor() {
        super()
        this.setDisplay(Displays.block)
      }
    }

    class SectionTitle extends View {
      text = new Text()
      removeButton = new IconButton()

      constructor() {
        super()
        this
          .setDisplay(Displays.flex)
          .setJustifyContent(Justifies.space_between)
          .setColor(Colors.text)
          .setFontSize(1)
          .setLineHeight(1)
          .setPadding('0 0 .4rem 0')
          .setFontWeight(FontWeights.bold)
          .setBorderBottom(`2px solid ${Colors.border_lighter}`)
          .setMargin('2rem 0 0 0')
          .addView(this.text)
          .addView(this.removeButton
            .setBGImage('css/destroy.png')
            .setDisplay(Displays.none))
      }

      setText(strValue) {
        this.text.setContent(strValue)
      }

      enableRemove(isEnable = true) {
        if (isEnable) {
          this.onmouseenter = () => this.removeButton.setDisplay(Displays.block)
          this.onmouseleave = () => this.removeButton.setDisplay(Displays.none)
        } else {
          this.onmouseenter = undefined
          this.onmouseleave = undefined
        }
        return this
      }
    }

    class Section extends View {
      _tasks = []
      _placeholder = new Text()
      _title = new SectionTitle()
      _onDragStart = _ => undefined
      _onDragEnd = () => undefined
      _onDrop = _ => undefined
      _beforeAddTask = _ => undefined
      _treatFirst = _ => undefined

      constructor() {
        super()
        this
          .setDisplay(Displays.block)
          .addView(this._title)
          .addView(this._placeholder
            .setContent('无'))

        this.ondragover = e => e.preventDefault()
        this.ondragstart = e => this._onDragStart(e.target)
        this.ondrop = e => this._onDrop(e.target)
        this.ondragend = e => this._onDragEnd()
      }

      setTitle(strValue) {
        this._title.setText(strValue)
        return this
      }

      enableClear(isEnable = true) {
        this._title.enableRemove(isEnable)
        return this
      }

      onDragStart(action) {
        this._onDragStart = action
        return this
      }

      onDragEnd(action) {
        this._onDragEnd = action
        return this
      }

      onDrop(action) {
        this._onDrop = action
        return this
      }

      beforeAddTask(action) {
        this._beforeAddTask = action
        return this
      }

      treatFirst(action) {
        this._treatFirst = action
        return this
      }

      addTask(task) {
        if (0 === this._tasks.length) {
          this.cutView(this._placeholder)
          this._treatFirst(task)
        }
        this._beforeAddTask(task)
        this._tasks.push(task)
        return this.addView(task)
      }

      cutTask(task) {
        const index = this._tasks.indexOf(task)
        if (index >= 0) {
          this._tasks.splice(index, 1)
          this.cutView(task)

          if (0 === index && this._tasks.length > 0) {
            this._treatFirst(this._tasks[0])
          }
        }

        if (this._tasks.length) {
          this.addView(this._placeholder)
        }
        return this
      }
    }

    class Counter extends View {
      _generateContent = count => `count: ${count}`

      constructor() {
        super()
      }

      setContentGenerator(action) {
        this._generateContent = action
        return this
      }

      setCount(value) {
        return this.setContent(this._generateContent(value))
      }
    }

    class CounterButton extends Counter {
      constructor() {
        super()
        this
          .setDisplay(Displays.block)
          .setFontSize(.6)
          .setPadding('0 1rem')
          .setBGColor(Colors.button_bg)
          .setLineHeight(1.2)
          .setRadius('.6rem')
          .setShadow(`0 -1px 0 0 ${Colors.shadow_lighter}`)
          .setCursor(Cursors.pointer)

        this.onmouseenter = () => {
          this.setBGColor(Colors.shadow_lighter)
        }

        this.onmouseout = () => {
          this.setBGColor(Colors.button_bg)
        }
      }

      setCount(value) {
        if (value > 0) {
          this.setDisplay(Displays.block)
        } else {
          this.setDisplay(Displays.none)
        }
        return super.setCount(value)
      }
    }

    class Footer extends View {
      totalCounter = new Counter()
      buttonsContainer = new View()
      completeCounter = new CounterButton()
      pendingCounter = new CounterButton()

      constructor() {
        super()
        this
          .setDisplay(Displays.flex)
          .setJustifyContent(Justifies.space_between)
          .setAlignItems(Aligns.center)
          .setPadding('1rem')
          .setFontSize(.8)
          .setColor(Colors.text)
          .setBGColor(Colors.footer_bg)
          .setShadow(`0 2px 6px -1px ${Colors.shadow_lighter}`)
          .setBorderTop(`1px solid ${Colors.border_lighter}`)
          .addView(this.totalCounter
            .setContentGenerator(count => `${count} 项活动任务`)
            .setCount(0),
          )
          .addView(this.buttonsContainer
            .setDisplay(Displays.flex)
            .addView(this.completeCounter
              .setContentGenerator(count => `清除 ${count} 项已完成任务`)
              .setCount(1),
            )
            .addView(this.pendingCounter
              .setContentGenerator(count => `清除 ${count} 项已挂起任务`)
              .setCount(1),
            ),
          )
      }
    }

    class Input extends View {
      view = document.createElement('input')
      _isFocused = false

      constructor() {
        super()
        this
          .setDisplay(Displays.block)
          .setMargin('1rem 0 0 0')
          .addView(this.view)
        this.view.style.fontSize = '1rem'
        this.view.style.padding = '.3rem'
        this.view.style.boxSizing = 'border-box'
        this.view.style.width = '100%'
        this.view.placeholder = '请输入任务'

        this.view.onfocus = () => {
          this._isFocused = true
        }

        this.view.onblur = () => {
          this._isFocused = false
        }
      }

      get isFocused() {
        return this._isFocused
      }

      focus(options) {
        this.view.focus(options)
      }
    }

    class Task extends View {
      _prefixDot = new ColoredDot()
      _text = new Text()

      constructor() {
        super()
        this
          .setDisplay(Displays.grid)
          .setAlignItems(Aligns.center)
          .setGridColumn('1rem 1fr 1rem', '.5rem')
          .addView(this._prefixDot)
          .addView(this._text)
        this.draggable = true
      }

      setText(strValue) {
        this._text.setContent(strValue)
        return this
      }

      setPrefixColor(strValue) {
        this._prefixDot.setBGColor(strValue)
        return this
      }

      setDotAnimation(strValue) {
        this._prefixDot.setAnimation(strValue)
        return this
      }
    }

    class Container extends View {
      constructor() {
        super()
        this
          .setDisplay(Displays.block)
          .setBGColor(Colors.white)
          .setPadding('1rem')
          .setShadow(`0 2px 6px 0 ${Colors.shadow_lighter}`)
      }
    }

    class IconButton extends View {
      constructor() {
        super()
        this
          .setDisplay(Displays.block)
          .setBGRepeat(Repeats.no_repeat)
          .setBGSize('1rem auto')
          .setBGPosition('0 0')
          .setWidth('1rem')
          .setHeight('1rem')

        this.onmouseenter = () => this.setBGPosition('0 -1rem')
        this.onmouseleave = () => this.setBGPosition('0 0')
      }
    }

    class ColoredDot extends View {
      constructor() {
        super()
        this
          .setWidth('1rem')
          .setHeight('1rem')
          .setDisplay(Displays.block)
          .setRadius('.5rem')
          .setMargin('0 5px 0 0')
      }
    }

    customElements.define('text-view', Text)
    customElements.define('colored-dot', ColoredDot)
    customElements.define('icon-button', IconButton)
    customElements.define('container-view', Container)
    customElements.define('section-view', Section)
    customElements.define('section-title', SectionTitle)
    customElements.define('simple-input', Input)
    customElements.define('page-footer', Footer)
    customElements.define('counter-view', Counter)
    customElements.define('counter-button', CounterButton)
    customElements.define('base-view', View)
    customElements.define('task-view', Task)

    let isMouseDown = false
    window.onmousedown = () => {
      isMouseDown = true
    }
    window.onmouseup = () => {
      isMouseDown = false
    }
    let
      draggingTask = undefined,
      hello = undefined

    const
      footer = new Footer(),
      input = new Input(),
      output = new Text()
        .setHeight('1rem')
        .setLineHeight(1),
      wipSection = new Section()
        .setTitle('进行中')
        .enableClear(false)
        .beforeAddTask(task => task.setPrefixColor(Colors.yellow))
        .treatFirst(task => task.setDotAnimation('active_color 1s infinite')),
      completeSection = new Section()
        .setTitle('已完成')
        .enableClear()
        .beforeAddTask(task => task.setPrefixColor(Colors.green)),
      pendingSection = new Section()
        .setTitle('已挂起')
        .enableClear()
        .beforeAddTask(task => task.setPrefixColor(Colors.gray)),
      container = new Container()
        .addView(input)
        .addView(output)
        .addView(wipSection)
        .addView(pendingSection)
        .addView(completeSection)
    body
      .append(container)
      .append(footer)

    const
      log = msg => output.setContent(msg || ''),
      onDraw = () => requestAnimationFrame(() => {
        if (false === input.isFocused && false === isMouseDown) {
          input.focus()
        }
        onDraw()
      })
    onDraw()

    console.log(
      '%c>>>>%c Log indicate%c developing.',
      'color: #353535; font-weight: 700;',
      'color: deepskyblue;',
      'color: darkgreen;',
    )

    const one_moment = 20
    const one_second = 50 * one_moment
    const one_minute = 60 * one_second
    const one_hour = 60 * one_minute
    const one_day = 24 * one_hour
    const two_digit = num => (num < 10 ? `0${num}` : num)
    const time_str = interval => {
      const day = Math.floor(interval / one_day)
      const hour = Math.floor((interval % one_day) / one_hour)
      const minute = Math.floor((interval % one_hour) / one_minute)
      const second = Math.floor((interval % one_minute) / one_second)
      const millisecond = interval % one_second
      const ms = (millisecond < 10 ? `00${millisecond}`
          : (millisecond < 100 ? `0${millisecond}`
              : millisecond
          )
      )
      return `${day}D${two_digit(hour)}:${two_digit(minute)}:${two_digit(second)}.${ms}`
    }

    const s = selector => p_dom(document.querySelector(selector))
    const p_dom = dom => {
      if (!dom) {
        return dom
      }
      const classes = () => {
        const trimmed_class = (dom.className && dom.className.trim()) || ''
        return trimmed_class.length > 0 ? trimmed_class.split(/\s+/) : []
      }
      const worker = {
        is_proxy: true,
        view: dom,
        s: selector => p_dom(dom.querySelector(selector)),
        set: (key, value) => {
          dom.setAttribute(key, value)
          return pd
        },
        attr: name => dom.getAttribute(name),
        append: child => {
          if (child.is_proxy) {
            dom.appendChild(child.view)
          } else {
            dom.appendChild(child)
          }
          return pd
        },
        insert: (view, locator) => {
          view = view.is_proxy ? view.view : view
          locator = locator.is_proxy ? locator.view : locator
          dom.insertBefore(view, locator)
          return pd
        },
        add_class: clz => {
          const old_ones = classes()
          if (!clz || old_ones.includes(clz)) {
            return pd
          }
          old_ones.push(clz)
          dom.className = old_ones.join(' ')
          return pd
        },
        remove_class: clz => {
          if (!clz) {
            return pd
          }
          const old_ones = classes()
          const idx = old_ones.indexOf(clz)
          if (idx < 0) {
            return pd
          }
          old_ones.splice(idx, 1)
          dom.className = old_ones.join(' ')
          return pd
        },
        prev: () => {
          let prev = dom.previousSibling
          while (prev instanceof Text) {
            prev = prev.previousSibling
          }
          return p_dom(prev)
        },
      }

      const handler = {
        get: (view, key, _/*receiver*/) => {
          if (worker.hasOwnProperty(key)) {
            return worker[key]
          }
          return view[key]
        },
        set: (view, key, value, _/*receiver*/) => {
          view[key] = value
          return value
        },
      }

      const pd = new Proxy(dom, handler)
      return pd
    }

    const url_base = 'https://www.gsegment.com/tms'
    const msg_login = 'login please'
    const post = (url, data) => new Promise((res, rej) => {
      fetch(
        `${url_base}/${url}?session=${localStorage.tm_session}`,
        {
          method: 'POST',
          body: JSON.stringify(data),
          headers: {
            'Content-Type': 'application/json',
          },
        },
      ).then(
        resp => resp.json().then(
          result => {
            if (msg_login === result.msg) {
              rej({msg: '请先登录 - 输入框输入 email:your_email'})
            } else {
              res(result)
            }
          },
        ).catch(
          err => rej({err, msg: 'receive json failed'}),
        ),
      ).catch(
        err => rej({err, msg: 'fetch failed'}),
      )
    })
    const login = (email, password) => new Promise((res, rej) => {
      post('user', {email, password}).then(
        ({success, session}) => {
          if (success) {
            localStorage.tm_session = session
            res(success)
          } else {
            rej({msg: '登录信息有误'})
          }
        },
      ).catch(err => rej(err))
    })
    const list_task = () => post('task/list')
    const save_task = task => post('task', task).then(({success, _id}) => {
      if (success) {
        task._id = _id
      } else {
        log('任务保存失败，请咨询服务器管理员')
      }
    }).catch(error => {
      log('任务保存失败', error)
    })

    /*const notification = new Notification('test', {
      body: 'damn',
      requireInteraction: true,
      icon: 'css/task_manager.png',
      image: 'css/task_manager.png'
    })*/

    const task_state = {
      in_progress: 'wip',
      completed: 'done',
      pending: 'hung',
    }

    const create_task = obj => {
      // TODO Perhaps make this the true model
      // TODO Use proxy to wrap the task
      // TODO add get 'view' with proxy dom value
      // TODO add get 'data' with values need persistence
      // TODO add get 'state' with values only exists at runtime
      // TODO Use extended HTMLElement instead of css classes
      const data = {
        _id: false,
        desc: false,
        state: task_state.in_progress,
        sn: 0,
        is_activated: false,
        is_cleared: false,
        timeCost: 0,
        startTime: 0,
      }
      for (const key in data) {
        if (false === obj.hasOwnProperty(key)) {
          continue
        }
        data[key] = obj[key]
      }
      const self = {}
      if (obj._id) {
        self._id = obj._id
      }
      self.desc = obj.desc
      self.is_activated = obj.is_activated || false
      self.is_cleared = obj.is_cleared || false
      self.state = obj.state || task_state.in_progress
      self.timeCost = obj.timeCost || 0  // In milliseconds.
      self.startTime = obj.startTime || 0  // Invalid value.
      self.sn = obj.sn || 0 // Only work for active tasks.

      let h_displaying = false

      const clear_displaying = () => {
        if (false === h_displaying) {
          return
        }
        clearInterval(h_displaying)
        h_displaying = false
      }

      const inactivate = state => {
        self.state = state
        if (false === self.is_activated) {
          return
        }
        self.timeCost += (Date.now() - self.startTime)
        self.startTime = 0
        self.is_activated = false
        clear_displaying()
      }

      self.activate = view => {
        self.state = task_state.in_progress
        if (self.is_activated) return
        self.startTime = self.startTime || Date.now()
        self.is_activated = true
        h_displaying = setInterval(() => {
          const display = view.s('.time_cost')
          display.remove_class('hide')
          display.innerHTML = time_str(self.get_time_cost())
        }, one_moment)
      }

      self.inactivate = () => inactivate(task_state.in_progress)
      self.complete = () => inactivate(task_state.completed)
      self.pend = () => inactivate(task_state.pending)

      self.get_time_cost = () => {
        const increment = self.is_activated ? (Date.now() - self.startTime) : 0
        return (self.timeCost + increment)
      }
      return self
    }

    const task_view_template = ''
    const done_view_template = ''

    const e_from = (template, model) => {
      const container = p_dom(document.createElement('div'))
      for (const key in model) {
        if (model.hasOwnProperty(key)) {
          template = template.replace(new RegExp('{' + key + '}', 'g'), '' + model[key])
        }
      }
      container.innerHTML = template
      return container.s('div')
    }

    const input_box = s('.new_task') // New Task View.
    const output_box = s('.output_box')
    const trait_login = 'email:'
    const credentials = {}
    const clear_input = () => (input_box.value = '')
    const check_input_type = type => (type === input_box.attr('type'))
    const is_text_inputting = () => check_input_type('text')
    const set_input_attr = obj => {
      for (const k in obj) {
        if (obj.hasOwnProperty(k)) {
          input_box.set(k, obj[k])
        }
      }
    }
    input_box && (input_box.onkeydown = e => {
      if (e.key === 'Enter' && input_box.value) {
        const desc = input_box.value
        clear_input()
        if (is_text_inputting()) {
          if (desc.startsWith(trait_login)) {
            credentials.email = desc.substr(trait_login.length, desc.length)
            set_input_attr({
              placeholder: '输入密码',
              type: 'password',
            })
          } else {
            create_wip_task(create_task({desc}))
          }
        } else {
          set_input_attr({
            placeholder: '输入新任务',
            type: 'text',
          })
          login(credentials.email, desc).catch(
            res => log(`登录失败 : ${res.msg}`),
          )
        }
      } else {
        log()
      }
    })

    const in_progress_view = s('.in_progress') // In-progress Tasks View.
    const completed_view = s('.completed')   // Completed Tasks View.
    const pending_view = s('.pending')   // Pending Tasks View.

    const in_progress_tasks = (() => {
      const wip_view = []
      const get_worker = {
        last: () => wip_view[wip_view.length - 1],
        is_empty: () => (0 === wip_view.length),
      }
      const wip_handler = {
        get: (_, key) => {
          if (get_worker.hasOwnProperty(key)) {
            return get_worker[key]
          }
          return wip_view[key]
        },
        set: (_, key, val) => {
          wip_view[key] = val
          return true
        },
      }
      return new Proxy(wip_view, wip_handler)
    })()
    const completed_tasks = []  // Completed Tasks Model.
    const pending_tasks = []  // Pending Tasks Model.
    /////// Globals initialized. ///////

    const update_footer = () => {
      let itCount = in_progress_tasks.length
      let ctCount = completed_tasks.length
      let ccCount = pending_tasks.length

      s('.it-count').innerHTML = itCount + ' '
      s('.ct-count').innerHTML = ' ' + ctCount + ' '
      s('.cc-count').innerHTML = ' ' + ccCount + ' '
      const cc = s('.clear_completed')
      if (ctCount > 0) {
        cc.remove_class('hide')
      } else {
        cc.add_class('hide')
      }
      const cp = s('.clear_pending')
      if (ccCount > 0) {
        cp.remove_class('hide')
      } else {
        cp.add_class('hide')
      }
    }

    const create_wip_task = (task, is_init) => {  // Create In-progress Task.
      const obj = {desc: task.desc}
      const d = e_from(task_view_template, obj)
      if (in_progress_tasks.is_empty()) {
        task.activate(d)
      }
      in_progress_view.append(d)

      show_time(task, d)

      // Synchronize data.
      if (!is_init) {
        task.sn = (
          in_progress_tasks.is_empty() ?
            0 : (in_progress_tasks.last().sn + 1)
        )
        task.state = task_state.in_progress
        save_task(task)
      }
      in_progress_tasks.push(task)

      update_footer()
      return d
    }

    const passively_active = () => {
      const top = in_progress_view.s('.task:nth-of-type(1)')
      if (!top) {
        return
      }
      const desc = top.s('span').innerHTML
      const top_task = get_by_desc(in_progress_tasks, desc)
      top_task.activate(top)
      save_task(top_task)
    }

    const move_item_up = item => { // Only work for in_progress tasks
      const prevItem = item.prev()
      const content = prevItem.s('span').innerHTML
      const task = remove_a_task(item, in_progress_tasks)
      in_progress_view.insert(item, prevItem)
      return insert_by_desc(in_progress_tasks, content, task)
    }

    const activate_wip_task = (view, is_init) => {
      // De-activate the current active task.
      const top = in_progress_view.s('.task:nth-of-type(1)')
      const top_task = in_progress_tasks[0]
      top_task.inactivate()
      if (!is_init) {
        save_task(top_task)
      }
      show_time(top_task, top)

      // Activate the selected task.
      const task = remove_a_task(view, in_progress_tasks)  // Temporarily remove the selected task.
      const locator = in_progress_view.s('.task:nth-of-type(1)')
      if (locator) {  // Move current task to the head of the list.
        in_progress_view.insert(view, locator)
      } else {
        in_progress_view.append(view)
      }

      // Synchronize the storage.
      in_progress_tasks.splice(0, 0, task)
      task.activate(view)
      show_time(task, view)
      if (!is_init) {
        task.sn = top_task.sn - 1
        save_task(task)
      }

      update_footer()
    }

    const get_by_desc = (arr, desc) => {
      for (const t of arr) {
        if (desc === t.desc) {
          return t
        }
      }
      return undefined
    }

    const remove_by_desc = (arr, desc) => {
      let index = 0
      for (const t of arr) {
        if (desc === t.desc) {
          return arr.splice(index, 1)[0]
        }
        ++index
      }
      return undefined
    }

    const insert_by_desc = (arr, desc, toInsert) => {
      let index = 0
      for (const t of arr) {
        if (desc === t.desc) {
          const sn = toInsert.sn
          toInsert.state = task_state.in_progress
          toInsert.sn = t.sn
          t.sn = sn
          arr.splice(index, 0, toInsert)
          return t
        }
        ++index
      }
      return undefined
    }

    const remove_a_task = (view, type) => {  // Remove In-progress Task.
      // Remove the task view from the page.
      const c = view.parentNode
      c.removeChild(view.is_proxy ? view.view : view)

      const taskDesc = view.s('span').innerText
      const task = remove_by_desc(type, taskDesc)
      task.complete()

      update_footer()
      return task
    }

    const create_done_task = (task, is_init) => {  // Create Completed Task.
      task.complete()

      const obj = {desc: task.desc, icon_color: 'green'}
      const d = e_from(done_view_template, obj)
      completed_view.append(d)

      show_time(task, d)

      // Synchronize data.
      completed_tasks.push(task)  // Perhaps 0-100 means progress? Or an object.
      if (!is_init) {
        save_task(task)
      }

      update_footer()
      return d
    }

    const create_pending_task = (task, is_init) => {  // Create Pending Task.
      task.pend()

      const obj = {desc: task.desc, icon_color: 'gray'}
      const d = e_from(done_view_template, obj)
      pending_view.append(d)
      // Bind handler to the remove button.
      show_time(task, d)

      // Synchronize data.
      pending_tasks.push(task)  // Perhaps 0-100 means progress? Or an object.
      if (!is_init) {
        save_task(task)
      }

      update_footer()
      return d
    }

    const show_time = (task, view) => {
      if (!view) {
        return
      }
      if (task.get_time_cost() > 0) {
        const a = view.s('.time_cost')
        a.remove_class('hide')
        a.innerHTML = time_str(task.get_time_cost())
      }
    }

    const clear_completed_handler = () => {
      let task = completed_view.s('.task')
      while (task) {
        const t = remove_a_task(task, completed_tasks)
        t.is_cleared = true
        save_task(t)
        task = completed_view.s('.task')
      }
    }

    const clear_pending_handler = () => {
      let task = pending_view.s('.task')
      while (task) {
        const t = remove_a_task(task, pending_tasks)
        t.is_cleared = true
        save_task(t)
        task = pending_view.s('.task')
      }
    }

    list_task().then(result => {
      const {
        success,
        tasks,
      } = result
      if (false === success) {
        log('取数据失败 : 请咨询服务器管理员')
        return
      }
      tasks.sort(({sn: a}, {sn: b}) => {
        a = a || 0
        b = b || 0
        return a - b
      })
      // Init the tasks.
      for (const task of tasks) {
        if (task_state.in_progress === task.state) {
          wipSection.addTask(new Task()
            .setText(task.desc))
        } else if (task_state.completed === task.state) {
          completeSection.addTask(new Task()
            .setText(task.desc))
        } else {
          pendingSection.addTask(new Task()
            .setText(task.desc))
        }
      }
    }).catch(res => {
      console.log(res, '<<<<<<< Error')
      log(`取数据失败 : ${res.msg}`)
    })
  })</script>
  <title>日常任务管理</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="shortcut icon" href="css/task_manager.png"/>
  <style media="screen">
    @keyframes active_color {
      from {
        background-color: #ddcc00;
      }
      30% {
        background-color: #00ff00;
      }
      70% {
        background-color: #dd0000;
      }
      to {
        background-color: #ddcc00;
      }
    }
  </style>
  <style media="screen">
    html, body {
      padding: 0;
      margin: 0;
      font-family: Microsoft YaHei, monospace;
      user-select: none;
      /*pointer-events: none;*/
    }

    body {
      width: 640px;
      margin: 0 auto;
      background: #eeeeee;
      color: #333333;
    }
  </style>
</head>
<body></body>
</html>
