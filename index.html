<!DOCTYPE html>
<html>
<head>
  <title>日常任务管理</title>
  <link rel="shortcut icon" href="css/task_manager.png" />
  <link rel="stylesheet" href="css/style.css" />
  <script id='in_progress_task' type='text/template'>
    <div class="{div_class}">
      <a class="{icon_class}"></a>
      <span>{desc}</span>
      <a class="remove_btn" title="挂起任务"></a>
      <a class="complete-btn" title="标记已完成任务"></a>
      <a class="activate-btn" title="任务置顶(激活)"></a>
      <a class="up-btn">上移</a>
      <a class="time-cost hide" title="已花费时间(分钟)">0</a>
    </div>
  </script>
  <script id='inactive_task' type='text/template'>
    <div class="{div_class}">
      <a class="colored-icon {icon_color}"></a>
      <span>{desc}</span>
      <a class="remove_btn" title="移除任务"></a>
      <a class="roll-btn" title="恢复活跃"></a>
      <a class="time-cost hide" title="时间花费(分钟)">0</a>
    </div>
  </script>
</head>
<body>
  <div id="contents"><!-- 主内容块的开始标签。 -->
    <!--
      总的来说，有 3 栏数据，
      一栏是输入新任务和显示未完成任务的地方，
      一栏是已完成任务，
      还有一栏是已取消任务。
    -->
    <!-- 每个任务有开始时间、花费时间的属性。 -->
    <div id="in_progress" style="text-align: center">
      <h1>日常任务管理工具</h1>
      <input id="new_task" type="text" placeholder="输入新任务" />
      <div class='output_box'></div>
      <div class="seg_divider">活跃的任务▽</div>
    </div>

    <div class="seg_divider">完成的任务▽<a
      class="remove_btn"
      id="clear_completed_btn"
      title="移除所有已完成任务"
    ></a></div>

    <div id="completed">
    </div>

    <div class="seg_divider">挂起的任务▽<a
      class="remove_btn"
      id="clear_pending_btn"
      title="移除所有挂起的任务"
    ></a></div>

    <div id="pending">
    </div>
  </div><!-- 主内容块的结束标签。 -->

  <div id="footer">
      <b id="it-count">0 </b>项活动任务
      <a
        id="clear-completed"
        class="hide"
      >清除<b id="ct-count"> 0 </b>项已完成任务</a>
      <a
        id="clear-pending"
        class="hide"
      >清除<b id="cc-count"> 0 </b>项已挂起任务</a>
  </div>
</body>

<script>
(() => {
  console.log(
    '%c>>>> %cLog indicate %cdeveloping.',
    'color: #353535; font-weight: 700;',
    'color: deepskyblue;',
    'color: darkgreen;'
  )
  
  //const url_base = '/tms' //XXX Use this for deploy
  const url_base = 'http://localhost:3100'
  const msg_login = 'login please'
  const post = (url, data) => new Promise((res, rej) => {
    fetch(
      `${url_base}/${url}?session=${localStorage.session}`,
      {
        method: 'POST',
        body: JSON.stringify(data),
        headers: {
          'Content-Type': 'application/json'
        }
      }
    ).then(
      resp => resp.json().then(
        result => {
          if (msg_login === result.msg) {
            rej({ msg: '请先登录' })
          } else {
            res(result)
          }
        }
      ).catch(
        err => rej({ err, msg: 'receive json failed' })
      )
    ).catch(
      err => rej({ err, msg: 'fetch failed' })
    )
  })
  const login = (email, password) => new Promise((res, rej) => {
    post('user', { email, password }).then(
      ({ success, session }) => {
        if (success) {
          localStorage.session = session
          res(success)
        } else {
          rej({ msg: '登录信息有误' })
        }
      }
    ).catch(err => rej(err))
  })
  const list_task = () => post('task/list')
  
  const s = (selector, context) => (
    context = context || document,
    context.querySelector(selector)
  )

  /*const notifi = new Notification('hehe', {
    body: 'damn',
    requireInteraction: true,
    icon: 'css/task_manager.png',
    image: 'css/task_manager.png'
  })*/

  function Task(obj){
    const self = this
    self.desc = obj.desc
    self.startTime = obj.startTime || 0  // Invalid value.
    self.activated = obj.activated || false
    self.timeCost = obj.timeCost || 0  // In milliseconds.
    self.sn = obj.sn || 0 // Only work for active tasks.
    
    let h_displaying = false
    
    const clear_displaying = () => {
      if (false === h_displaying) {
        return
      }
      clearInterval(h_displaying)
      h_displaying = false
    }

    self.activate = view => {
      if(self.activated) return
      self.startTime = Date.now()
      self.activated = true
      h_displaying = setInterval(() => {
        const time_cost = (self.timeCost + Date.now() - self.startTime) / 60000
        const display = s('.time-cost', view)
        display.className = 'time-cost'
        display.innerHTML = `${Math.round(time_cost)}`
      }, 10000)
    }

    self.complete = self.pend = () => {
      if(!self.activated) return
      self.timeCost += Date.now() - self.startTime
      self.startTime = 0
      self.activated = false
      clear_displaying()
    }

    self.getTimeCost = () => {
      return Math.round(self.timeCost / 60000)  // Return time in minutes.
    }
  }

  const itt = s('#in_progress_task').innerHTML
  const cAptt = s('#inactive_task').innerHTML
  
  const e_from = (template, model) => {
    const container = document.createElement('div')
    for (const key in model) {
      template = template.replace(
        new RegExp('{' + key + '}', 'g'),
        '' + model[key]
      )
    }
    container.innerHTML = template
    return container.querySelector('div')
  }

  const input_box = s('#new_task') // New Task View.
  const output_box = s('.output_box')
  const log = msg => output_box.innerHTML = msg || ''
  const trait_login = 'email:'
  const credentials = {}
  const clear_input = () => (input_box.value = '')
  const check_input_type = type => (type === input_box.getAttribute('type'))
  const is_text_inputing = () => check_input_type('text')
  const is_password_inputing = () => check_input_type('password')
  const set_input_attr = obj => {
    for (const k in obj) {
      input_box.setAttribute(k, obj[k])
    }
  }
  input_box.onkeydown = e => {
    if(e.keyCode === 13 && input_box.value){
      const desc = input_box.value
      clear_input()
      if (is_text_inputing()) {
        if (desc.startsWith(trait_login)) {
          credentials.email = desc.substr(trait_login.length, desc.length)
          set_input_attr({
            placeholder: '输入密码',
            type: 'password'
          })
        } else {
          create_wip_task(new Task({ desc }))
        }
      } else {
        set_input_attr({
          placeholder: '输入新任务',
          type: 'text'
        })
        login(credentials.email, desc).catch(
          res => log(`登录失败:${res.msg}`)
        )
      }
    } else {
      log()
    }
  }

  const itv = s('#in_progress') // In-progress Tasks View.
  const ctv = s('#completed')   // Completed Tasks View.
  const ptv = s('#pending')   // Pending Tasks View.

  const itm = []  // In-progress Tasks Model.
  const ctm = []  // Completed Tasks Model.
  const ptm = []  // Pending Tasks Model.
  const store = {inProgress: itm, completed: ctm, pending: ptm}
  /////// Globals initialized. ///////

  const update_footer = () => {
    let itCount = itm.length
    let ctCount = ctm.length
    let ccCount = ptm.length

    s('#it-count').innerHTML = itCount + ' '
    s('#ct-count').innerHTML = ' ' + ctCount + ' '
    s('#cc-count').innerHTML = ' ' + ccCount + ' '
    s('#clear-completed').className = (ctCount > 0) ? '' : 'hide'
    s('#clear-pending').className = (ccCount > 0) ? '' : 'hide'
  }

  const create_wip_task = task => {  // Create In-progress Task.
    const obj = {desc: task.desc}
    if(null === s('.task', itv)){
      obj.icon_class = 'colored-icon active'
      obj.div_class = 'task top'
    }else{
      obj.icon_class = 'colored-icon yellow'
      obj.div_class = 'task'
    }
    const d = e_from(itt, obj)
    if (obj.div_class === 'task top') {
      task.activate(d)
    }
    itv.appendChild(d)

    // Bind handler to the buttons.
    s('.remove_btn', d).onclick = () => {
      // Pend a task.
      remove_a_task(d, itm)
      create_pending_task(task)
    }
    s('.complete-btn', d).onclick = () => {
      // Complete a task.
      remove_a_task(d, itm)
      create_done_task(task)
    }
    s('.activate-btn', d).onclick = () => {
      // Activate a task.
      activate_wip_task(d)
    }
    s('.up-btn', d).onclick = () => {
      // Move a task up one row.
      move_item_up(d)
    }

    show_time(task, d)

    // Synchronize data.
    itm.push(task)
    localStorage.tasksInfo = JSON.stringify(store)

    update_footer()
    return d
  }

  const move_item_up = item => { // Only work for in_progress tasks
    const prevItem = get_prev_sibling(item)
    const isSecond = prevItem.className.includes('top')
    if (isSecond) {
      return
    }
    const content = prevItem.getElementsByTagName('span')[0].innerHTML
    const task = remove_a_task(item, itm)
    itv.insertBefore(item, prevItem)
    insert_by_desc(itm, content, task)
    localStorage.tasksInfo = JSON.stringify(store)
  }

  const activate_wip_task = view => {
    // De-activate the current active task.
    const top = s('.top', itv)
    s('.active', top).className = 'colored-icon yellow'
    top.className = 'task'
    let task = itm[0]
    task.pend()
    show_time(task, top)

    // Activate the selected task.
    task = remove_a_task(view, itm)  // Temporarily remove the selected task.
    const locator = s('.seg_divider', itv).nextSibling
    if(locator != null){  // Move current task to the head of the list.
      itv.insertBefore(view, locator)
    }else{
      itv.appendChild(view)
    }
    // Mark current task as active.
    s('.colored-icon', view).className = 'colored-icon active'
    view.className = 'task top'

    // Synchronize the storage.
    itm.splice(0, 0, task)
    task.activate(view)
    localStorage.tasksInfo = JSON.stringify(store)

    update_footer()
  }

  const get_prev_sibling = view => {
    const { previousSibling } = view
    return (previousSibling instanceof Text) ? previousSibling.previousSibling : previousSibling
  }

  const get_next_sibling = view => {
    const { nextSibling } = view
    return (nextSibling instanceof Text) ? nextSibling.nextSibling : nextSibling
  }

  const get_by_desc = (arr, desc) => {
    for (const t of arr) {
      if (desc === t.desc) {
        return t
      }
    }
    return undefined
  }

  const remove_by_desc = (arr, desc) => {
    let index = 0
    for (const t of arr) {
      if (desc === t.desc) {
        return arr.splice(index, 1)[0]
      }
      ++index
    }
    return undefined
  }

  const insert_by_desc = (arr, desc, toInsert) => {
    let index = 0
    for (const t of arr) {
      if (desc === t.desc) {
        arr.splice(index, 0, toInsert)
        return toInsert
      }
      ++index
    }
    return undefined
  }

  const remove_a_task = (view, type) => {  // Remove In-progress Task.
    // Remove the task view from the page.
    const c = view.parentNode
    const nextTask = get_next_sibling(view)
    if(view.className == 'task top' && nextTask != null && nextTask.className == 'task'){
      nextTask.className = 'task top'
      if(type == itm){
        s('.colored-icon', nextTask).className = 'colored-icon active'
        get_by_desc(itm, s('span', nextTask).innerHTML).activate(nextTask)
      }
    }
    c.removeChild(view)

    // Remove it from the localStorage.
    const taskDesc = view.getElementsByTagName('span')[0].innerHTML
    const task = remove_by_desc(type, taskDesc)
    task.complete()
    localStorage.tasksInfo = JSON.stringify(store)

    update_footer()
    return task
  }

  const create_done_task = task => {  // Create Completed Task.
    task.complete()

    const obj = {desc: task.desc, icon_color:'green'}
    if(null === s('.task', ctv)){
      obj.div_class = 'task top'
    }else{
      obj.div_class = 'task'
    }
    const d = e_from(cAptt, obj)
    ctv.appendChild(d)

    // Bind handler to the remove button.
    s('.remove_btn', d).onclick = () => {
      remove_a_task(d, ctm)
    }
    s('.roll-btn', d).onclick = () => {
      remove_a_task(d, ctm)
      create_wip_task(task)
    }

    show_time(task, d)

    // Synchronize data.
    ctm.push(task)  // Perhaps 0-100 means progress? Or an object.
    localStorage.tasksInfo = JSON.stringify(store)

    update_footer()
    return d
  }

  const create_pending_task = task => {  // Create Pending Task.
    task.pend()

    const obj = {desc:task.desc, icon_color:'gray'}
    if(null === s('.task', ptv)){
      obj.div_class = 'task top'
    }else{
      obj.div_class = 'task'
    }
    const d = e_from(cAptt, obj)
    ptv.appendChild(d)
    // Bind handler to the remove button.
    s('.remove_btn', d).onclick = () => {
      remove_a_task(d, ptm)
    }
    s('.roll-btn', d).onclick = () => {
      remove_a_task(d, ptm)
      create_wip_task(task)
    }

    show_time(task, d)

    // Synchronize data.
    ptm.push(task)  // Perhaps 0-100 means progress? Or an object.
    localStorage.tasksInfo = JSON.stringify(store)

    update_footer()
    return d
  }

  const show_time = (task, view) => {
    if(task.getTimeCost() > 0){
      const a = s('.time-cost', view)
      a.className = 'time-cost'
      a.innerHTML = task.getTimeCost()
    }
  }

  s('#clear_completed_btn').onclick =
  s('#clear-completed').onclick = () => {
    const tasks = ctv.getElementsByClassName('task')
    while(tasks[0] != undefined){
      remove_a_task(tasks[0], ctm)
    }
  }

  s('#clear_pending_btn').onclick =
  s('#clear-pending').onclick = () => {
    const tasks = ptv.getElementsByClassName('task')
    while(tasks[0] != undefined){
      remove_a_task(tasks[0], ptm)
    }
  }

  list_task().then(res => console.log('====', res)).catch(
    res => log(`取数据失败:${res.msg}`)
  )
  const data = localStorage.tasksInfo
  if(data == undefined) return
  // Init the tasks.
  const { inProgress, completed, pending } = JSON.parse(data)
  const toSort = []
  for (let key in inProgress) {
    const t = new Task(inProgress[key])

    toSort.push(t)
    let i = inProgress[key]
    if(i == undefined) return
    i = new Task(i)
    if(i.activated){
      activate_wip_task(create_wip_task(i))
    }else{
      create_wip_task(i)
    }
  }
  for (let key in completed) {
    if(completed[key] == undefined) return
    create_done_task(new Task(completed[key]))
  }
  for (let key in pending) {
    if(pending[key] == undefined) return
    create_pending_task(new Task(pending[key]))
  }
})()
</script>
</html>
